From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: DynamicDevices <support@dynamicdevices.co.uk>
Date: Fri, 10 Jan 2025 14:00:00 +0000
Subject: [PATCH] wifi: Don't clear secrets if stored in keyfile for headless systems

On headless systems without secret agents, NetworkManager should retry
with existing PSK from connection file instead of clearing secrets and
requesting new ones when 4-way handshake fails.

This prevents the "no secrets" error that blocks auto-reconnection on
headless embedded systems. When secrets are stored in the connection
file (psk-flags=0), we should retry with the existing PSK rather than
assuming the PSK is wrong and requesting new secrets from a non-existent
secret agent.

Signed-off-by: DynamicDevices <support@dynamicdevices.co.uk>

---
 src/core/devices/wifi/nm-device-wifi.c | 30 +++++++++++++++++++++++++++++-
 1 file changed, 29 insertions(+), 1 deletion(-)

diff --git a/src/core/devices/wifi/nm-device-wifi.c b/src/core/devices/wifi/nm-device-wifi.c
index b890b11052..c1d2e3f4a5 100644
--- a/src/core/devices/wifi/nm-device-wifi.c
+++ b/src/core/devices/wifi/nm-device-wifi.c
@@ -2377,6 +2377,7 @@ handle_8021x_or_psk_auth_fail(NMDeviceWifi              *self,
 {
     NMDevice     *device = NM_DEVICE(self);
     NMActRequest *req;
+    NMConnection *applied_connection;
     const char   *setting_name = NULL;
     gboolean      handled      = FALSE;
 
@@ -2386,6 +2387,33 @@ handle_8021x_or_psk_auth_fail(NMDeviceWifi              *self,
     req = nm_device_get_act_request(NM_DEVICE(self));
     g_return_val_if_fail(req != NULL, FALSE);
 
+    applied_connection = nm_act_request_get_applied_connection(req);
+    if (applied_connection) {
+        NMSettingWirelessSecurity *s_wsec;
+        NMSettingSecretFlags       secret_flags = NM_SETTING_SECRET_FLAG_NONE;
+        gboolean                   secrets_in_file = FALSE;
+
+        s_wsec = nm_connection_get_setting_wireless_security(applied_connection);
+        if (s_wsec) {
+            /* Check if PSK is stored in file (not agent-only) */
+            if (nm_setting_get_secret_flags(NM_SETTING(s_wsec),
+                                            NM_SETTING_WIRELESS_SECURITY_PSK,
+                                            &secret_flags,
+                                            NULL)) {
+                /* If secret flags are NONE or NOT_REQUIRED, secrets are in file */
+                if (!(secret_flags & NM_SETTING_SECRET_FLAG_NOT_SAVED)) {
+                    secrets_in_file = TRUE;
+                }
+            } else {
+                /* If we can't get secret flags, assume secrets are in file */
+                secrets_in_file = TRUE;
+            }
+        }
+
+        /* On headless systems, if secrets are in file, retry with existing PSK
+         * instead of clearing and requesting new secrets */
+        if (secrets_in_file) {
+            _LOGI(LOGD_DEVICE | LOGD_WIFI,
+                  "Activation: (wifi) 4-way handshake failed, but secrets are in file. Retrying with existing PSK instead of requesting new secrets.");
+            /* Don't clear secrets - let NetworkManager retry with existing PSK */
+            return FALSE;
+        }
+    }
+
     if (need_new_8021x_secrets(self, old_state, &setting_name)
         || need_new_wpa_psk(self, old_state, disconnect_reason, &setting_name)) {
         nm_act_request_clear_secrets(req);
 
         _LOGI(LOGD_DEVICE | LOGD_WIFI,
               "Activation: (wifi) disconnected during association, asking for new key");
 
         cleanup_association_attempt(self, TRUE);
         nm_device_state_changed(device,
                                 NM_DEVICE_STATE_NEED_AUTH,
                                 NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
         wifi_secrets_get_secrets(self,
                                  setting_name,
                                  NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION
                                      | NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW);
         handled = TRUE;
     }
 
     return handled;
 }
